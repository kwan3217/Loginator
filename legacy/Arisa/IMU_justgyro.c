#include "IMU.h"
#include "kalman.h"
#include "gyro.h"
#include "compass.h"
#include "setup.h"
#include "pktwrite.h"
#include <math.h>
#include "sensor.h"
#include "serial.h"
#include "main.h"

fp Bix,Biy,Biz;

kalMatrices(IMU_M,imu);
kalman_state k_IMU;

#define quat_guts(a)   \
  fp w2=w*w; \
  fp x2=x*x; \
  fp y2=y*y; \
  fp z2=z*z; \
  fp result; \
  fp xy=x*y; \
  fp wz=w*z; \
  fp xz=x*z; \
  fp wy=w*y; \
  fp yz=y*z; \
  fp wx=w*x; \
  fp Mx,My,Mz; \
  if(comp==0) { \
    Mx=(w2+x2-y2-z2); \
    My=2*(xy+wz); \
    Mz=2*(xz-wy); \
  } else if(comp==1) { \
    Mx=2*(xy-wz); \
    My=(w2+x2-y2-z2); \
    Mz=2*(yz+wx); \
  } else { \
    Mx=2*(xz+wy); \
    My=2*(yz-wx); \
    Mz=(w2+x2-y2-z2); \
  } \
  result=Mx*a##x+My*a##y+Mz*a##z; \

void quatNormalize(void) {
  fp elen=sqrt(k_IMU.xh.data[0]*k_IMU.xh.data[0]+
               k_IMU.xh.data[1]*k_IMU.xh.data[1]+
               k_IMU.xh.data[2]*k_IMU.xh.data[2]+
               k_IMU.xh.data[3]*k_IMU.xh.data[3]);
  k_IMU.xh.data[0]/=elen;
  k_IMU.xh.data[1]/=elen;
  k_IMU.xh.data[2]/=elen;
  k_IMU.xh.data[3]/=elen;
}

//Sometimes you only need one component of a transformed vector
fp i2b_comp(fp Ix, fp Iy, fp Iz, int comp) {
  fp w=k_IMU.xh.data[0];
  fp x=k_IMU.xh.data[1];
  fp y=k_IMU.xh.data[2];
  fp z=k_IMU.xh.data[3];
  quat_guts(I);
  return result;
}

extern circular sensorBuf;

//Same as above, but with quaternion conjugate
fp b2i_comp(fp Bx, fp By, fp Bz, int comp) {
  fp w=k_IMU.xh.data[0];
  fp x=-k_IMU.xh.data[1];
  fp y=-k_IMU.xh.data[2];
  fp z=-k_IMU.xh.data[3];

  fillPktStart(&sensorBuf,PT_I2C);
  fillPktString(&sensorBuf,"b2i_comp");
  fillPktFP(&sensorBuf,w);
  fillPktFP(&sensorBuf,x);
  fillPktFP(&sensorBuf,y);
  fillPktFP(&sensorBuf,z);
  quat_guts(B);
  fillPktFP(&sensorBuf,xy);
  fillPktFP(&sensorBuf,wz);
  fillPktFP(&sensorBuf,xz);
  fillPktFP(&sensorBuf,wy);
  fillPktFP(&sensorBuf,yz);
  fillPktFP(&sensorBuf,wx);
  fillPktFP(&sensorBuf,Bx);
  fillPktFP(&sensorBuf,By);
  fillPktFP(&sensorBuf,Bz);
  fillPktFP(&sensorBuf,Mx);
  fillPktFP(&sensorBuf,My);
  fillPktFP(&sensorBuf,Mz);
  fillPktFP(&sensorBuf,result);
  fillPktFinish(&sensorBuf);
  drainToSD(&sensorBuf);
  return result;
}

int initIMU() {
  int result=kalInit(k_IMU,IMU_M,imu,F_IMU,Phi_IMU);
  if(result<0) return result;
  k_IMU.xh.data[0]=1;
  for(int i=0;i<IMU_M;i++) px(&k_IMU.P,i,i,1.0);
  for(int i=4;i<IMU_M;i++) px(&k_IMU.Q,i,i,0.01);
  return 0;
}

int imuUpdate(sensor* s) {
  fp dt=ekf_update_time(&k_IMU,s->TC);
  for(int i=0;i<s->n_k;i++) {
    if(s->g_ofs+i>IMU_N) return -i*2-1;
    assertmx(ekf_step(&k_IMU, i==0?dt:0, s->cal[i], s->R[i], g_IMU[s->g_ofs+i], H_IMU[s->g_ofs+i]),-i*2-2);
  }
  quatNormalize();
  return 0;
}

void writeIMUstate(circular *buf,int result) {
  fillPktStart(buf,PT_I2C);
  fillPktString(buf,"IMU");
  fillPktInt(buf,result);
  fillPktInt(buf,k_IMU.lastUpdate/60);
  fillPktInt(buf,k_IMU.lastUpdate%60);
  for(int i=0;i<k_IMU.xh.row;i++) fillPktFP(buf,k_IMU.xh.data[i]);
  fillPktFinish(buf);
}

/* function doJac pwd %Generate the physics functions and jacobians
  syms ew ex ey ez wx wy wz m n Bix Biy Biz real;
  x=[ew;ex;ey;ez;wx;wy;wz];
  e=[ex;ey;ez];
  w=[wx;wy;wz];
  F=[ quatmultiply([ew,e'],[0,w'])'/2;0;0;0]
  etilde=[ 0, -ez, ey
           ez, 0, -ex
          -ey, ex, 0];
  E=2*e*e'+(ew^2-e'*e)*eye(3)-2*ew*etilde;
  Bi=[Bix;Biy;Biz];
  EBi=E*Bi;
  g=[wx;wy;wz;EBi;ew;ex;ey;ez]
  Phi=jacobian(F,x)
  H=jacobian(g,x)
  F=matlabFunction(F,'file','F_IMU','vars',{x})
  g=matlabFunction(g,'file','g_IMU','vars',{x, Bix, Biy, Biz, m, n})
  ouf=fopen('g_IMU.m','a');fwrite(ouf,'if(nargin>4),g=g(m:n);,end;');fclose(ouf);
  Phi=matlabFunction(Phi,'file','Phi_IMU','vars',{x})
  H=matlabFunction(H,'file','H_IMU','vars',{x, Bix, Biy, Biz, m, n})
  ouf=fopen('H_IMU.m','a');fwrite(ouf,'if(nargin>4),g=H(m:n,:);,end;');fclose(ouf);
end
*/

int F_IMU(matrix* F, matrix* x) {
//F_IMU
//    F = F_IMU(x)

//    This function was generated by the Symbolic Math Toolbox version 5.5.
//    04-Apr-2011 19:11:27

// Translated to C 06-Apr-2011 by Chris Jeppesen
#ifdef CHECK_COMPAT
  if(F->row!=7) return -1;
  if(F->col!=1) return -2;
  if(x->row!=7) return -3;
  if(x->col!=1) return -4;
#endif
  fp ew = x->data[0];
  fp ex = x->data[1];
  fp ey = x->data[2];
  fp ez = x->data[3];
  fp wx = x->data[4];
  fp wy = x->data[5];
  fp wz = x->data[6];
  F->data[0] = ex*wx*(-1.0/2.0)-ey*wy*(1.0/2.0)-ez*wz*(1.0/2.0);
  F->data[1] = ew*wx*( 1.0/2.0)+ey*wz*(1.0/2.0)-ez*wy*(1.0/2.0);
  F->data[2] = ew*wy*( 1.0/2.0)-ex*wz*(1.0/2.0)+ez*wx*(1.0/2.0);
  F->data[3] = ew*wz*( 1.0/2.0)+ex*wy*(1.0/2.0)-ey*wx*(1.0/2.0);
  F->data[4] = 0.0;
  F->data[5] = 0.0;
  F->data[6] = 0.0;
  return 0;
}

int Phi_IMU(matrix* Phi,matrix* x) {
  //PHI_IMU
  //    PHI = PHI_IMU(x)

  //    This function was generated by the Symbolic Math Toolbox version 5.5.
  //    04-Apr-2011 19:11:28

#ifdef CHECK_COMPAT
  if(Phi->row!=7) return -1;
  if(Phi->col!=7) return -2;
  if(x->row!=7) return -3;
  if(x->col!=1) return -4;
#endif
  fp ew = x->data[0];
  fp ex = x->data[1];
  fp ey = x->data[2];
  fp ez = x->data[3];
  fp wx = x->data[4];
  fp wy = x->data[5];
  fp wz = x->data[6];
  fp t418 = wz*(1.0/2.0);
  fp t419 = wx*(1.0/2.0);
  fp t420 = ew*(1.0/2.0);
  fp t421 = wy*(1.0/2.0);
  fp t422 = ey*(1.0/2.0);

  Phi->data[idx(Phi,0,0)] = 0.0;
  Phi->data[idx(Phi,1,0)] = t419;
  Phi->data[idx(Phi,2,0)] = t421;
  Phi->data[idx(Phi,3,0)] = t418;

  Phi->data[idx(Phi,0,1)] = wx*(-1.0/2.0);
  Phi->data[idx(Phi,1,1)] = 0.0;
  Phi->data[idx(Phi,2,1)] = -t418;
  Phi->data[idx(Phi,3,1)] = t421;

  Phi->data[idx(Phi,0,2)] = wy*(-1.0/2.0);
  Phi->data[idx(Phi,1,2)] = t418;
  Phi->data[idx(Phi,2,2)] = 0.0;
  Phi->data[idx(Phi,3,2)] = -t419;

  Phi->data[idx(Phi,0,3)] = wz*(-1.0/2.0);
  Phi->data[idx(Phi,1,3)] = wy*(-1.0/2.0);
  Phi->data[idx(Phi,2,3)] = t419;
  Phi->data[idx(Phi,3,3)] = 0.0;

  Phi->data[idx(Phi,0,4)] = ex*(-1.0/2.0);
  Phi->data[idx(Phi,1,4)] = t420;
  Phi->data[idx(Phi,2,4)] = ez*(1.0/2.0);
  Phi->data[idx(Phi,3,4)] = -t422;

  Phi->data[idx(Phi,0,5)] = ey*(-1.0/2.0);
  Phi->data[idx(Phi,1,5)] = ez*(-1.0/2.0);
  Phi->data[idx(Phi,2,5)] = t420;
  Phi->data[idx(Phi,3,5)] = ex*(1.0/2.0);

  Phi->data[idx(Phi,0,6)] = ez*(-1.0/2.0),
  Phi->data[idx(Phi,1,6)] = t422;
  Phi->data[idx(Phi,2,6)] = ex*(-1.0/2.0);
  Phi->data[idx(Phi,3,6)] = t420;
  for(int row=4;row<7;row++) {
    for(int col=0;col<7;col++) {
      Phi->data[idx(Phi,row,col)]=0.0;
    }
  }
  return 0;
}

fp g0_IMU(matrix* x) {
  //G_IMU
  //    G = G_IMU(IN1,BIX,BIY,BIZ,M,N)

  //    This function was generated by the Symbolic Math Toolbox version 5.5.
  //    04-Apr-2011 19:11:28
  // Translated to C 06-Apr-2011 by Chris Jeppesen
#ifdef CHECK_COMPAT
  if(x->row!=7) return -1;
  if(x->col!=1) return -2;
#endif
  fp wx = x->data[4];
  return wx;
}

fp g1_IMU(matrix* x) {
  //G_IMU
  //    G = G_IMU(IN1,BIX,BIY,BIZ,M,N)

  //    This function was generated by the Symbolic Math Toolbox version 5.5.
  //    04-Apr-2011 19:11:28
  // Translated to C 06-Apr-2011 by Chris Jeppesen
#ifdef CHECK_COMPAT
  if(x->row!=7) return -1;
  if(x->col!=1) return -1;
#endif
  fp wy = x->data[5];
  return wy;
}

fp g2_IMU(matrix* x) {
  //G_IMU
  //    G = G_IMU(IN1,BIX,BIY,BIZ,M,N)

  //    This function was generated by the Symbolic Math Toolbox version 5.5.
  //    04-Apr-2011 19:11:28
  // Translated to C 06-Apr-2011 by Chris Jeppesen
#ifdef CHECK_COMPAT
  if(x->row!=7) return -1;
  if(x->col!=1) return -2;
#endif
  fp wz = x->data[6];
  return wz;
}

fp g3_IMU(matrix* x) {
  //G_IMU
  //    G = G_IMU(IN1,BIX,BIY,BIZ,M,N)

  //    This function was generated by the Symbolic Math Toolbox version 5.5.
  //    04-Apr-2011 19:11:28
  // Translated to C 06-Apr-2011 by Chris Jeppesen
#ifdef CHECK_COMPAT
  if(x->row!=7) return -1;
  if(x->col!=1) return -2;
#endif
  fp ew = x->data[0];
  fp ex = x->data[1];
  fp ey = x->data[2];
  fp ez = x->data[3];
  fp t408 = ew*ez*2.0;
  fp t409 = ex*ey*2.0;
  fp t410 = ew*ew;
  fp t411 = ex*ex;
  fp t412 = ey*ey;
  fp t413 = ez*ez;
  fp t414 = ew*ey*2.0;
  return  Bix*(t410+t411-t412-t413)-Biz*(t414-ex*ez*2.0)     +Biy*(t408+t409);
}

fp g4_IMU(matrix* x) {
  //G_IMU
  //    G = G_IMU(IN1,BIX,BIY,BIZ,M,N)

  //    This function was generated by the Symbolic Math Toolbox version 5.5.
  //    04-Apr-2011 19:11:28
  // Translated to C 06-Apr-2011 by Chris Jeppesen
#ifdef CHECK_COMPAT
  if(x->row!=7) return -1;
  if(x->col!=1) return -2;
#endif
  fp ew = x->data[0];
  fp ex = x->data[1];
  fp ey = x->data[2];
  fp ez = x->data[3];
  fp t408 = ew*ez*2.0;
  fp t409 = ex*ey*2.0;
  fp t410 = ew*ew;
  fp t411 = ex*ex;
  fp t412 = ey*ey;
  fp t413 = ez*ez;
  fp t415 = ew*ex*2.0;
  fp t416 = ey*ez*2.0;
  return -Bix*(t408-t409)          +Biy*(t410-t411+t412-t413)+Biz*(t415+t416);
}

fp g5_IMU(matrix* x) {
  //G_IMU
  //    G = G_IMU(IN1,BIX,BIY,BIZ,M,N)

  //    This function was generated by the Symbolic Math Toolbox version 5.5.
  //    04-Apr-2011 19:11:28
  // Translated to C 06-Apr-2011 by Chris Jeppesen
#ifdef CHECK_COMPAT
  if(x->row!=7) return -1;
  if(x->col!=1) return -2;
#endif
  fp ew = x->data[0];
  fp ex = x->data[1];
  fp ey = x->data[2];
  fp ez = x->data[3];
  fp t410 = ew*ew;
  fp t411 = ex*ex;
  fp t412 = ey*ey;
  fp t413 = ez*ez;
  fp t414 = ew*ey*2.0;
  fp t415 = ew*ex*2.0;
  fp t416 = ey*ez*2.0;
  return -Biy*(t415-t416)          +Biz*(t410-t411-t412+t413)+Bix*(t414+ex*ez*2.0);
}

int H0_IMU(matrix* H,matrix* x) {
  //%H_IMU
  //%    H = H_IMU(IN1,BIX,BIY,BIZ,M,N)

  //%    This function was generated by the Symbolic Math Toolbox version 5.5.
  //%    04-Apr-2011 19:11:28

#ifdef CHECK_COMPAT
  if(H->row!=1) return -1;
  if(H->col!=7) return -2;
  if(x->row!=7) return -3;
  if(x->col!=1) return -4;
#endif
  H->data[0] = 0.0;
  H->data[1] = 0.0;
  H->data[2] = 0.0;
  H->data[3] = 0.0;
  H->data[4] = 1.0;
  H->data[5] = 0.0;
  H->data[6] = 0.0;
  return 0;
}

int H1_IMU(matrix* H,matrix* x) {
  //%H_IMU
  //%    H = H_IMU(IN1,BIX,BIY,BIZ,M,N)

  //%    This function was generated by the Symbolic Math Toolbox version 5.5.
  //%    04-Apr-2011 19:11:28

#ifdef CHECK_COMPAT
  if(H->row!=1) return -1;
  if(H->col!=7) return -2;
  if(x->row!=7) return -3;
  if(x->col!=1) return -4;
#endif
  H->data[0]=0.0;
  H->data[1]=0.0;
  H->data[2]=0.0;
  H->data[3]=0.0;
  H->data[4]=0.0;
  H->data[5]=1.0;
  H->data[6]=0.0;
  return 0;
}

int H2_IMU(matrix* H,matrix* x) {
  //%H_IMU
  //%    H = H_IMU(IN1,BIX,BIY,BIZ,M,N)

  //%    This function was generated by the Symbolic Math Toolbox version 5.5.
  //%    04-Apr-2011 19:11:28

#ifdef CHECK_COMPAT
  if(H->row!=1) return -1;
  if(H->col!=7) return -2;
  if(x->row!=7) return -3;
  if(x->col!=1) return -4;
#endif
  H->data[0]=0.0;
  H->data[1]=0.0;
  H->data[2]=0.0;
  H->data[3]=0.0;
  H->data[4]=0.0;
  H->data[5]=0.0;
  H->data[6]=1.0;
  return 0;
}

int H3_IMU(matrix* H,matrix* x) {
  //%H_IMU
  //%    H = H_IMU(IN1,BIX,BIY,BIZ,M,N)

  //%    This function was generated by the Symbolic Math Toolbox version 5.5.
  //%    04-Apr-2011 19:11:28

#ifdef CHECK_COMPAT
  if(H->row!=1) return -1;
  if(H->col!=7) return -2;
  if(x->row!=7) return -3;
  if(x->col!=1) return -4;
#endif
  fp ew = x->data[0];
  fp ex = x->data[1];
  fp ey = x->data[2];
  fp ez = x->data[3];
  fp t424 = Biy*ew*2.0;
  fp t425 = Biz*ex*2.0;
  fp t437 = Bix*ez*2.0;
  fp t426 = t424+t425-t437;
  fp t427 = Biy*ex*2.0;
  fp t428 = Bix*ex*2.0;
  fp t429 = Biy*ey*2.0;
  fp t430 = Biz*ez*2.0;
  fp t431 = t428+t429+t430;
  fp t432 = Bix*ew*2.0;
  fp t433 = Biy*ez*2.0;
  H->data[0] = t432+t433-Biz*ey*2.0;
  H->data[1] = t431;
  H->data[2] = t427-Biz*ew*2.0-Bix*ey*2.0;
  H->data[3] = t426;
  H->data[4] = 0.0;
  H->data[5] = 0.0;
  H->data[6] = 0.0;
  return 0;
}

int H4_IMU(matrix* H,matrix* x) {
  //%H_IMU
  //%    H = H_IMU(IN1,BIX,BIY,BIZ,M,N)

  //%    This function was generated by the Symbolic Math Toolbox version 5.5.
  //%    04-Apr-2011 19:11:28

#ifdef CHECK_COMPAT
  if(H->row!=1) return -1;
  if(H->col!=7) return -2;
  if(x->row!=7) return -3;
  if(x->col!=1) return -4;
#endif
  fp ew = x->data[0];
  fp ex = x->data[1];
  fp ey = x->data[2];
  fp ez = x->data[3];
  fp t424 = Biy*ew*2.0;
  fp t425 = Biz*ex*2.0;
  fp t437 = Bix*ez*2.0;
  fp t426 = t424+t425-t437;
  fp t427 = Biy*ex*2.0;
  fp t428 = Bix*ex*2.0;
  fp t429 = Biy*ey*2.0;
  fp t430 = Biz*ez*2.0;
  fp t431 = t428+t429+t430;
  fp t432 = Bix*ew*2.0;
  fp t433 = Biy*ez*2.0;
  fp t434 = Biz*ew*2.0;
  fp t435 = Bix*ey*2.0;
  fp t436 = -t427+t434+t435;
  fp t438 = Biz*ey*2.0;
  H->data[0] = t426;
  H->data[1] = t436;
  H->data[2] = t431;
  H->data[3] = -t432-t433+t438;
  H->data[4] = 0.0;
  H->data[5] = 0.0;
  H->data[6] = 0.0;
  return 0;
}

int H5_IMU(matrix* H,matrix* x) {
  //%H_IMU
  //%    H = H_IMU(IN1,BIX,BIY,BIZ,M,N)

  //%    This function was generated by the Symbolic Math Toolbox version 5.5.
  //%    04-Apr-2011 19:11:28

#ifdef CHECK_COMPAT
  if(H->row!=1) return -1;
  if(H->col!=7) return -2;
  if(x->row!=7) return -3;
  if(x->col!=1) return -4;
#endif
  fp ew = x->data[0];
  fp ex = x->data[1];
  fp ey = x->data[2];
  fp ez = x->data[3];
  fp t424 = Biy*ew*2.0;
  fp t425 = Biz*ex*2.0;
  fp t437 = Bix*ez*2.0;
  fp t427 = Biy*ex*2.0;
  fp t428 = Bix*ex*2.0;
  fp t429 = Biy*ey*2.0;
  fp t430 = Biz*ez*2.0;
  fp t431 = t428+t429+t430;
  fp t432 = Bix*ew*2.0;
  fp t433 = Biy*ez*2.0;
  fp t434 = Biz*ew*2.0;
  fp t435 = Bix*ey*2.0;
  fp t436 = -t427+t434+t435;
  fp t438 = Biz*ey*2.0;
  H->data[0] = t436;
  H->data[1] = -t424-t425+t437;
  H->data[2] = t432+t433-t438;
  H->data[3] = t431;
  H->data[4] = 0.0;
  H->data[5] = 0.0;
  H->data[6] = 0.0;
  return 0;
}

const gfunc g_IMU[]={g0_IMU,g1_IMU,g2_IMU,g3_IMU,g4_IMU,g5_IMU};
const Ffunc H_IMU[]={H0_IMU,H1_IMU,H2_IMU,H3_IMU,H4_IMU,H5_IMU};
